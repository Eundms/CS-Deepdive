# 동시성 제어 (Concurrency Control)
> 여러 트랜잭션이동시에 실행될 때 데이터의 일관성을 유지하는 기법 

## 1. 낙관적 동시성 제어 (Optimistic Concurrency Control)
- 트랜잭션 충돌 가능성이 낮다고 가정하고, 트랜잭션이 끝난 후에 충돌을 검사하는 방식
- 읽기 연산이 많은 경우 성능이 뛰어남 (락이 없어서 대기 시간이 없음)
- 트랜잭션 충돌이 자주 발생하면 롤백 비용이 커짐

## 2. 비관적 동시성 제어 (Pessimistic Concurrency Control, PCC)
- 트랜잭션 충돌 가능성이 높다고 가정하고, 트랜잭션이 실행될 때 미리 락을 걸어 다른 트랜잭션의 접근을 방지
- 충돌이 많은 환경에서 데이터 일관성을 확실하게 보장
- 쓰기 연산이 많은 시스템에서 적합
- 잠금이 길어지면 성능 저하 (대기 시간이 길어질 수 있음)

### Locking (잠금 기법)
> 트랜잭션이 데이터에 접근하는 동안 다른 트랜잭션이 접근하지 못하도록 제어 

- Shared Lock(공유잠금; S-lock)
여러 트랜잭션이 읽기 가능, 수정 불가 
`SELECT ... LOCK IN SHARE MODE`

- Exclusive Lock (배타잠금; X-lock)
하나의 트랜잭션만 읽기/쓰기 가능, 다른 트랜잭션은 접근 불가  
`SELECT ... FOR UPDATE`

- 행 vs 테이블 레벨 잠금
개별 행 단위로 잠금 -> 동시성 높음 -> 성능 오버헤드 
테이블 단위로 잠금 -> 갇낟한 구현 -> 동시성 낮음  

> ! 데드락 발생 가능 하므로 타임아웃 설정, 트랜잭션 순서 설정 

## Multi-Version Concurrency Control
> 데이터를 변경할 때 기존 데이터를 바로 수정하지 않고, 새로운 버전을 생성하여 유지
- 트랜잭션이 데이터를 읽을 때 자신이 시작된 시점의 데이터 버전을 읽음
- 다른 트랜잭션의 변경 사항이 커밋되기 전까지는 보이지 않음
- 일반적으로 Undo Log(과거 버전) + Snapshot Isolation(스냅샷 격리) 을 사용하여 구현


