# 신뢰적인 데이터 전송 프로토콜 (reliable data transfer protocol) 
## rdt1.0: 완벽한 신뢰 채널
- 오류가 생길 수 없으므로 수신 측이 송신 측에게 어떤 피드백(feedback)도 제공할 필요가 없음

## rdt2.0: 비트 오류가 있는 채널 상에서의 신뢰적 데이터 전송
- `ARQ(Automatic Repeat reQuest) 프로토콜` : 컴퓨터 네트워크 설정에서 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜
    - 오류 검출 : 비트 오류를 수신자가 검출할 수 있어야 함
    - 수신자 피드백 : ACK, NAK과 같은 수신자 상태를 알기 위한 방법
    - 재전송 : 수신자에서 오류를 가지고 수신된 패킷은 송신자에 의해서 재전송됨
- == `전송 후 대기(stop-and-wait) 프로토콜` : 하나의 데이터를 전송하고 피드백을 받기 전까지 다음 데이터를 보내지 않는 방식
- 문제점 : 수신자 피드백을 나타내는 패킷도 손상될 수 있음
- 해결방안 
    - 1) 왜곡된 ACK, NAK 패킷을 수신할 때 현재 데이터 패킷을 단순히 다시 송신 : `중복 패킷`
    - 2) `순서번호(sequence number)` 삽입 : 데이터패킷에 송신자가 번호를 붙이기

## rdt3.0: 비트 오류, 손실 있는 채널 상에서의 신뢰적 데이터 전송
    - 카운트다운 타이머(countdown timer) : 주어진 시간이 경과된 후에 송신자 중단
    - == `얼터네이팅 비트 프로토콜(alternating-bit protocol)`


# 파이프라인된 신뢰적 데이터 전송 프로토콜
- 파이프라이닝, 필요한 순서번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜이 손실 패킷과 손상 패킷    그리고 상당히 지연된 패킷들에 대해 응답하는 방법에 의존함
- 파이프라인 오류 회복 2가지 기법 : `N부터 반복(Go-Back-N) - 슬라이딩 윈도우`, `선택적 반복(Selective Repeat, SR)` 

## N부터 반복(Go-Back-N) : 슬라이딩 윈도우 프로토콜
- 확인 응답이 안 된 가장 오래된 패킷의 순서번호를 base로 정의하고 사용되지 않은 가장 작은 순서번호를 전송될 다음 패킷의 순서번호(nextseqnum)로 정의한다. 
    - 허용할 수 있는 순서번호의 범위는 순서번호의 범위 상에서 크기가 N인 윈도우로 나타난다. N을 윈도우 크기라 부른다
    - 순서가 잘못되어 확인 응답이 안 된 가장 오랜 패킷의 순서번호보다 큰 값이 오면 해당 패킷은 버린다. (왜인지는 base의 의미를 생각해보자) 따라서, 패킷 하나의 오류 때문에 많은 패킷을 재전송할 수 있다.
- 타임아웃, ACK 패킷을 이용한다 
- 전송후대기 프로토콜에서의 채널 이용률 문제를 해결한다. 


## 선택적 반복(Selective Repeat, SR)
- 수신자에서 오류가 발생한 패킷을 수신했다고 의심되는 패킷만을 송신자가 다시 전송한다. 필요에 따라 개별적인 재전송은 개별적인 확인응답을 요구한다. 

### 세그먼트 구조에서 신뢰성 있는 데이터 전송을 담당하는 역할
- 체크섬 : 전송된 패킷 안의 비트 오류를 발견하는 데 사용한다
- 타이머 : 채널 안에서 패킷이 손실되었기 때문에 발생되는 패킷의 타임 아웃/재전송에 사용한다 
- 순서번호 : 송신자에서 수신자로 가는 데이터 패킷의 순서번호를 붙이기 위해서 사용된다
- 확인응답 : 패킷이 제대로 수신되었다는 사실을 송신자에게 알리기 위해 사용된다
- 부정 확인응답 : 정확히 수신되지 않았음을 알리기 위해 사용한다

