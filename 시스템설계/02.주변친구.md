# 주변 친구
## 1단계 : 문제 이해 및 설계 범위 확정
- 5mile, 직선거리
- 10억명 중 10% 기능 활용
- 이동 이력 보관 필요
- 10분 이상 비활성 상태 -> 사용자를 주변 친구 목록에서 제거

### 기능 요구사항
- 주변 친구 목록과 해당 친구까지의 거리 
- 마지막으로 갱신된 시각(timestamp)
- 친구 목록은 몇 초마다 한 번씩 갱신됨

### 비기능 요구사항
- 낮은 지연 시간 : 주변 친구의 위치 변화가 반영되는 데 너무 오래 걸리면 안됨
- 안정성
- 결과적 일관성 : 위치 데이터를 저장하기 위해 강한 일관성을 지원하는 데이터 저장소를 사용할 필요는 없음. 복제본의 데이터가 원본과 동일하게 변경되기까지 몇 초 정도 걸리는 것은 괜찮음

### 개략적 규모 추정
- 주변 친구 = 5마일 반경 이내 친구
- 친구 위치 정보 30초 주기로 갱신
- 매일 주변 친구 검색 기능 활용하는 사용자는 1억명으로 가정
- 동시 접속 사용자의 수는 DAU(일간 능동 사용자) 수의 10%로 가정
따라서, 천만 명이 동시에 시스템을 이용한다고 가정
- 400명의 친구를 가짐. 친구 검색 기능 활용함

#### QPS 계산
```
- 1억 DAU
- 동시 접속 사용자 : 10% * 1억 = 천만
- 30초마다 자기 위치를 시스템에 전송
- 위치 정보 갱신 QPS = 천만/30 = 334,000
```

## 2단계. 계락적 설계안 제시 및 동의 구하기
- 위치 정보를 모든 친구에게 전송(push)해야 한다 : HTTP 프로토콜 대신 사용

### 개략적 설계안
- 메시지의 효과적 전송을 가능하게 할 설계안 (근방의 모든 활성 상태 친구의 새 위치 정보 수신)
- P2P 방식 : 활성 상태인 근방 모든 친구와 통신 상태 유지
    - 통신 상태 
    - 전력도 충분치 않음
- 공용 백엔드 
    - 모든 활성 상태 위치 변화 내역 수신
    - 사용자 위치 변경 내역을 수신할 때마다 해당 사용자의 모든 활성 상태 친구를 찾아서 그 친구들의 단말로 변경 내역 전달
    - 두 사용자 사이의 거리가 특정 임계치보다 먼 경우 변경 내역을 전송하지 않음
    - 천만명의 위치 정보를 30초마다 갱신 => `334,000번/초`
    - 사용자 1명 400명의 친구 그 가운데 10%가 인근에서 활성화 상태 : 334,000 * 400 * 10% = `1400만건/초` 위치 정보 갱신 요청
- 설계안
    - 사용자 데이터베이스
    - 로드밸런서 : 부하 고르게 분산
    - 1) 웹소켓 서버 : 양방향 위치 정보
        - 레디스 Pub/Sub
        - 캐시 위치 정보 캐시
        - 위치 이동 이력 데이터베이스
    - 2) RESTful API 서버 : 사용자 관리, 친구 관리, 인증 및 기타 기능
        - CRUD

