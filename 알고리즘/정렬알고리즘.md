# 정렬 알고리즘 비교 표 
> 안정정렬 : 차례로 정렬(반드시)or 기존 순서 보장해야 할 때 

## 선택 정렬 (Selection Sort)
평균 시간 복잡도 : `O(N²)`  
공간 복잡도 : `O(1)`   
안정성 : ❌  
특징 : 교환 횟수가 적음, 구현 쉬움  

## 버블 정렬 (Bubble Sort)
평균 시간 복잡도 : `O(N²)`  
공간 복잡도 : `O(1)`  
안정성 : ✅  
특징 : `거의 정렬된 경우` 빠름, 구현이 매우 간단  

## 힙 정렬 (Heap Sort)
평균 시간 복잡도 : `O(N log N)`  
공간 복잡도 : `O(1)`  
안정성 : ❌ 
특징 : `추가 공간 없이 우선순위 기반 정렬`, 정렬 + 힙 응용 가능

## 병합 정렬 (Merge Sort)
평균 시간 복잡도 : `O(N log N)`  
공간 복잡도 : `O(N)`
안정성 : ✅   
특징 : `외부 정렬(데이터가 너무 커서 메모리(RAM)에 한 번에 다 올릴 수 없을 때)`에 적합, 큰 데이터도 안정적으로 처리 가능

## 퀵 정렬 (Quick Sort)
평균 시간 복잡도 : `O(N log N)`  
최악 시간 복잡도 : `O(N²)`  
공간 복잡도 : `O(log N)`  
안정성 : ❌ 
특징 : 대부분의 경우 매우 빠름, `내부 정렬(모든 데이터를 메모리에 올려놓고 정렬하는 방식)`에 적합

## 삽입 정렬 (Insertion Sort)
평균 시간 복잡도 : `O(N²)`  
공간 복잡도 : `O(1)`  
안정성 : ✅  
특징 : 대부분 정렬된 데이터에 매우 효과적, 작은 데이터에 적합  


## 기수 정렬 (Radix Sort)
평균 시간 복잡도 : `O(N × D) (D = 자릿수)`  
공간 복잡도 : `O(N + K)`  
안정성 : ✅ 
특징 : 자릿수가 정해진 정수 또는 `문자열 정렬`에 효과적


## 계수 정렬 (Counting Sort)
평균 시간 복잡도 : O(N + K) (K = 값의 범위)  
공간 복잡도 : O(K)  
안정성 : ✅
특징 : `정수 정렬`에만 사용 가능, 값의 범위가 작을 때 매우 효율적


## 버킷 정렬 (Bucket Sort)
평균 시간 복잡도 : `O(N + K) ` 
공간 복잡도 : `O(N + K)`  
안정성 : ✅ (버킷 내 정렬 방법에 따라 달라짐)  
특징 : 실수가 균등하게 분포되어 있을 때 빠름  

